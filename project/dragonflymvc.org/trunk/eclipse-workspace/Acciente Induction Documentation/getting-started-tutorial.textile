h1. Getting Started with Induction

h2. Introduction

Welcome to Induction! Induction is a powerful, lightweight framework for developing web applications using the Java(tm) programming language. Induction belongs to the class of web frameworks usually referred to as __request-based__ frameworks. Induction deploys as a servlet into a Java(tm) servlet container. Induction promotes the Model-View-Controller (MVC) approach to web application development. Some of the key design goals in Induction are:

* eliminate the need for web application reloads to test changes to models, views and controllers (we believe that a simple page refresh should suffice)

* bindings between controllers, views and models in declared in such way that they can be anaylzed using any IDE

* enable tracking of the data used in user interface templates (typically HTML templates) 

* file upload handling should be simple to the point of being unremarkable

* make it simple to use arrays and dictionary types in an HTML form

* use XML wisely (Induction requires only one XML file per application)

* an extensible architecture to support a range of usage patterns

* high performance

* compatibility with JDK versions 1.4 through 1.6 (both inclusive)

h2. About this tutorial

The goal of this tutorial is to get you running quickly using Induction. Induction requires a servlet container, in this tutorial we will use the "Apache Tomcat":http://tomcat.apache.org/ servlet container, but you are free to use any standards compliant servlet container.

h2. Installing 

We will assume that we have a Tomcat 6 installation in @c:/dev/Tomcat6@. Induction does not require any installation steps. The jar files for Induction can simply be included in your web application.

h2. Writing our first application

We will start our tutorial with controllers sinces controllers are a typical entry point into a web application. Let's start by writing our first controller that simply prints a string to the browser.

bc.. 
package demoapp.helloworld1_app;
 
import com.acciente.induction.controller.Controller;
import com.acciente.induction.controller.Response;
import java.io.IOException;

/**
 * A very simple controller that does the customary "Hello World"
  */
public class HelloWorldController implements Controller
{
   public void handler( Response oReponse ) throws IOException
   {
      oReponse.setContentType( "text/plain" );
      oReponse.out().println( "Hello World, using a simple println()" );
   }
}

p. Before we run this controller let's take a closer look. First we note that the @HelloWorldController@ class implements the Induction @Controller@ interface. The @Controller@ interface is simply a marker interface, it does not enforce any methods on the implementing class. When Induction receives a request to activate a controller implementation, such as our @HelloWorldController@ class, Induction first verifies that the class implements the @Controller@ interface. So currently the only reason for the @Controller@ interface is security. It is under consideration to make this requirement to implement the @Controller@ interface configurable.   

Next, note that the @handler@ method has a @Response@ input parameter. The @Response@ class extends the @javax.servlet.http.HttpServletResponse@ interface and is simply a facade to the servlet container's response object. This value for the @Response@ parameter is _injected_ into the @handler@ method by Induction.

Also note that @handler@ method is not bound to a fixed signature, it can declare its parameters using the following supported types: 

| *Type*        | *Description* |
| @Request@       | facade to the servlet request, extends javax.servlet.http.HttpServletRequest | 
| @Response@      | facade to the servlet response, extends javax.servlet.http.HttpServletResponse | 
| @Form@         | provides access to the HTML form (if any) submitted with this request | 
| @model_class_name@ | instance of a user provided model class, the instance is managed to conform to a user specified lifecycle | 

For brevity the class names above are not fully qualified, for the curious the Request, Response and Form classes are in the @com.acciente.induction.controller@ package.

h2. Deploying our application

Before we can run our controller it needs to be compiled. We can use @javac@ or any IDE to do this. Next we need to tell Tomcat about our web application. To do this we will create a @.war@ file and deploy it to Tomcat by copying it to @c:/dev/Tomcat6/webapps@. 

Our @.war@ file will contain the following files in the @WEB-INF@ folder:

bc. 
web.xml
induction-demoapp.xml 

The following Induction @.jar@ files WEB-INF/lib folder: 

bc. 
acciente-induction-beta-1.0.4.jar
acciente-commons-beta-1.0.4.jar

And finally the following supporting @.jar@ files from "Apache Commons":http://commons.apache.org/ ,  "Apache BCEL":http://jakarta.apache.org/bcel/ and "Freemarker":http://freemarker.sourceforge.net/ (Freemarker is one of the templating engines supported in Induction) also WEB-INF/lib folder: 

bc. 
apache-bcel-5.2.jar
apache-commons-collections-3.2.1.jar
apache-commons-digester-1.8.jar
apache-commons-fileupload-1.2.1.jar
apache-commons-io-1.4.jar
apache-commons-logging-1.1.1.jar
apache-freemarker-2.3.12.jar

Note that the code for our application classes (in this case just the controller class) are not stored inside the @.war@ file. We are going to point to the location of the compiled application code in @induction-demoapp.xml@. Whenever we recompile an application classes Induction will detect on the next access of that the respective application class that the underlying class file has changed and "hot" reload the class, therefore there is no need to recreate/redeploy the @.war@ when we change/compile the application classes. 

Induction, ofcourse, also supports putting our application classes in @/WEB-INF/classes@, in a @.jar@ in @/WEB-INF/lib@ or any other location in the classpath that Tomcat sees. Storing the application classes outside the @.war@ file is recommended during development to leverage "hot" reload. The application classes may be repackage into the @.war@ file for final delivery. 

First let's look at the contents of the @web.xml@, where we will define the Induction dispatcher servlet:

bc.. 
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
           version="2.5">
   <description>DemoApp</description>

   <servlet>
       <servlet-name>demoapp</servlet-name>
       <servlet-class>com.acciente.induction.dispatcher.HttpDispatcher</servlet-class>
       <load-on-startup>1</load-on-startup>
   </servlet>

   <servlet-mapping>
       <servlet-name>demoapp</servlet-name>
       <url-pattern>/*</url-pattern>
   </servlet-mapping>

</web-app>

p. Now let's look at the contents of @induction-demoapp.xml@, we will assume that our compiled application classes are stored in @c:/project/demoapp/classes@.

bc.. 
<!-- this file contains the configuration for the Induction dispatcher -->
<config>
	<!-- The following section allows you to specify locations from which
	Induction will automatically reload a class if the file has changed -->
	<java-class-path>
		<compiled-directory>
			<directory>c:/project/demoapp/classes</directory>
		</compiled-directory>
	</java-class-path>
</config> 

p. After creating the @.war@ as described above, deploy the @.war@ file to Tomcat. Now it's time to run our application.  

h2. Running our first application

Assuming your Tomcat is running on @localhost:8080@, if you point a browser to htpp://localhost:8080/demoapp/...



